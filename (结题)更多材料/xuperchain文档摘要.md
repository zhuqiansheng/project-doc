## 哈希

- 哈希算法，又称散列算法，它是一个单向函数，可以把任意长度的输入数据转化为固定长度的输出：

- 假设我们相信一个安全的哈希算法，那么我们认为，如果两个输入的哈希相同，我们认为两个输入是相同的。

- 如果输入的内容就是文件内容，而两个文件的哈希相同，说明文件没有被修改过。

>  当我们从网站上下载一个非常大的文件时，我们如何确定下载到本地的文件和官方网站发布的原始文件是完全相同，没有经过修改的呢？哈希算法就体现出了作用：我们只需要计算下载到本地的文件哈希，再和官方网站给出的哈希对比，如果一致，说明下载文件是正确的，没有经过篡改，如果不一致，则说明下载的文件肯定被篡改过。

大多数软件的官方下载页面会同时给出该文件的哈希值，以便让用户下载后验证文件是否被篡改：

和文件类似，如果两份数据的哈希相同，则可以100%肯定，两份数据是相同的。比特币使用哈希算法来保证所有交易不可修改，就是计算并记录交易的哈希，如果交易被篡改，那么哈希验证将无法通过，说明这个区块是无效的。

比特币使用的哈希算法有两种：SHA-256和RipeMD160

SHA-256的理论碰撞概率是：尝试2的130次方的随机输入，有99.8%的概率碰撞。注意2130是一个非常大的数字，大约是1361万亿亿亿亿。以现有的计算机的计算能力，是不可能在短期内破解的。

比特币使用两种哈希算法，一种是对数据进行两次SHA-256计算，这种算法在比特币协议中通常被称为hash256或者dhash。

另一种算法是先计算SHA-256，再计算RipeMD160，这种算法在比特币协议中通常被称为hash160

- 从Merkle Hash的计算方法可以得出结论：修改任意一个交易哪怕一个字节，或者交换两个交易的顺序，都会导致Merkle Hash验证失败，也就会导致这个区块本身是无效的，所以，Merkle Hash记录在区块头部，它的作用就是保证交易记录永远无法修改。

- 区块本身用Block Hash——也就是区块哈希来标识。但是，一个区块自己的区块哈希并没有记录在区块头部，而是通过计算区块头部的哈希得到的：

![image-20211018124041333](/Users/sens/Library/Application Support/typora-user-images/image-20211018124041333.png)



## 签名

- 数字签名的三个作用：**防伪造，防篡改，防抵赖。**
- 比特币采用的签名算法是椭圆曲线签名算法：ECDSA
- 比特币采用的ECDSA签名算法需要一个私钥和公钥组成的秘钥对：私钥本质上就是一个1～2256的随机数，**比特币的公钥是由私钥根据ECDSA算法推算出来的，通过私钥可以很容易推算出公钥**，所以不必保存公钥，但是，通过公钥无法反推私钥，只能暴力破解。
- 要特别注意，比特币的地址并不是公钥，而是公钥的哈希，即从公钥能推导出地址，但从地址不能反推公钥，因为哈希函数是单向函数。
- 类比银行卡：公钥 == 卡号，私钥==密码。不同之处在于，先确定私钥（密码），在计算出公钥（卡号），私钥不可更改，私钥丢失，钱就无法拿出来
- 对消息进行签名，实际上是对消息的哈希进行签名，这样可以使任意长度的消息在签名前先转换为固定长度的哈希数据。对哈希进行签名相当于保证了原始消息的不可伪造性。



## 多重签名

- 就是假设N个人分别持有N个私钥，只要其中M个人同意签名就可以动用某个“联合地址”的资金。

- 最常见的多重签名是2-3类型。

  例如，一个提供在线钱包的服务，为了防止服务商盗取用户的资金，可以使用2-3类型的多重签名地址，服务商持有1个私钥，用户持有两个私钥，一个作为常规使用，一个作为应急使用。这样，正常情况下，用户只需使用常规私钥即可配合服务商完成正常交易，服务商因为只持有1个私钥，因此无法盗取用户资金。如果服务商倒闭或者被黑客攻击，用户可使用自己掌握的两个私钥转移资金。

- 多重签名可以实现N个人持有私钥，其中M个人同意即可花费资金的功能。

- 多重签名降低了单个私钥丢失的风险。

- 支付比特币到一个多重签名地址实际上是创建一个P2SH输出。



## UTXO

- 还没有被下一个交易花费的Output被称为UTXO：Unspent TX Output，即未花费交易输出。
- 给定任何一个区块，计算当前所有的UXTO金额之和，等同于自创世区块到给定区块的挖矿奖励之和

在钱包程序中，钱包管理的是一组私钥，对应的是一组公钥和地址。钱包程序必须从创世区块开始扫描每一笔交易，如果：

1. 遇到某笔交易的某个Output是钱包管理的地址之一，则钱包余额增加；
2. 遇到某笔交易的某个Input是钱包管理的地址之一，则钱包余额减少



- 如果刚装了一个新钱包，导入了一组私钥，在钱包扫描完整个比特币区块之前，是无法得知当前管理的地址余额的。
- 但钱包在查询地址余额时，不必从头开始查，而是重建一个类似关系数据库的**地址-余额映射表**，使用关系数据库的主键进行查询，由于用了索引，速度极快。
- 一开始是一个空表，每当扫描一个区块的所有交易后，某些地址的余额增加，某些地址的余额减少，两者之差恰好为区块奖励：

![image-20211019142132447](/Users/sens/Library/Application Support/typora-user-images/image-20211019142132447.png)

这样，扫描完所有区块后，我们就得到了整个区块链所有地址的完整余额记录，查询的时候，并不是从区块链查询，而是从本地数据库查询。大多数钱包程序使用[LevelDB](https://github.com/google/leveldb)来存储这些信息，手机钱包程序则是请求服务器，由服务器查询数据库后返回结果。



- 以太坊的账户模型和比特币不同，它就是余额模型，即交易引发账户余额的变动，这与传统金融账户一致。

## 账户

以太坊中有两类账户（它们共用同一个地址空间）：

-  **外部账户** ：由公钥-私钥对（也就是人）控制；
-  **合约账户**：一种拥有合约代码的账户，它不属于任何人，也没有私钥与之对应。由和账户一起存储的代码控制.

**外部账户的地址是由公钥决定的**，而**合约账户的地址**是在创建该合约时确定的（这个**地址**通过合约创建者的地址和**从该地址发出过的交易数量**计算得到的，也就是所谓的“nonce”）

> 该地址应该指合约创建者的地址，所以nonce是合约创建者发出过的交易数量

- 无论帐户是否存储代码，这两类账户对 EVM 来说是一样的。
- 如果目标账户含有代码，此代码会被执行，并以 payload 作为入参
- 公钥是接收别人转账的地址，而私钥是花费比特币的唯一手段，钱包程序可以帮助用户管理私钥-公钥对，私钥是256bit的整数
- 私钥经过[Base58编码](https://zh.wikipedia.org/wiki/Base58)得到的字符串就是私钥地址，需要私密保存







## 以太坊交易

以太坊的交易需要消耗Gas，而Gas价格和实际消耗的数量决定了一个交易实际消耗的Ether，即交易成本。

合约交易无法精确地确定Gas数量，只能预估并给出Gas Limit。

![image-20211019144935753](/Users/sens/Library/Application Support/typora-user-images/image-20211019144935753.png)



## 智能合约

一个智能合约被编译后就是一段EVM字节码，将它部署在以太坊的区块链时，会根据部署者的地址和该地址的nonce分配一个合约地址，合约地址和账户地址的格式是没有区别的，但合约地址没有私钥，也就没有人能直接操作该地址的合约数据。**要调用合约，唯一的方法是调用合约的公共函数。**

这也是合约的一个限制：**合约不能主动执行，它只能被外部账户发起调用。如果一个合约要定期执行，那只能由线下服务器定期发起合约调用。**

此外，合约作为地址，可以接收Ether，也可以发送Ether。合约内部也可以存储数据。合约的数据存储在合约地址关联的存储上，这就使得**合约具有了状态**，可以实现比较复杂的逻辑，包括存款、取款等。

合约在执行的过程中，可**以调用其他已部署的合约**，前提是知道其他合约的地址和函数签名。

- 任何外部账户均可发起对合约函数的调用，但一个交易仅限一个函数调用



## 合约管理

- 部署合约的操作需要**由合约账号完成**，部署操作同样需要**支付手续费**，操作前需要确保**合约账号下有足够的余额**。运行时会提示手续费的数目，使用 –fee 参数传入即可
- 调用合约 invoke会产生一个交易，有gas和fee，调用query method不产生交易
- native合约默认关闭，java，go使用的native
- wasm合约有c++
- evm合约有solidity
- solidity.sol编译后生成abi文件。部署时给的是bin文件和abi文件
- XuperChain 有普通地址、合约账户以及合约名，这三类账户在EVM运行时需要转换为以太坊的地址类型（16进制编码字符串，形如0x1234567890abcdef1234567890abcdef12345678格式
- 可以将合约升级
- XuperCore 目前提供的智能合约使用了“预执行-执行”流程，当交易被提交到节点后，状态机通过验证后会被更改状态
- **合约部署后将自动获得一个地址，通过该地址即可访问合约。**
- 把`contract Vote {...}`看作一个类，部署就相当于一个实例化。如果部署两次，将得到两个不同的地址，相当于实例化两次，两个部署后的合约对应的成员变量是完全独立的，互不影响。
- 任何外部账户都可以发起对合约的函数调用。如果调用只读方法，因为不改变合约状态，所以任何时刻都可以调用，且不需要签名，也不需要消耗Gas。但如果调用写入方法，就需要签名提交一个交易，并消耗一定的Gas。
- 在一个交易中，只能调用一个合约的一个写入方法。无需考虑并发和同步的问题，因为以太坊交易的写入是严格串行的。
- 由于任何外部账户都可以发起对合约的函数调用，所以任何验证工作都必须在函数内部自行完成。最常用的`require()`可以断言一个条件，如果断言失败，将抛出错误并中断执行。所有检查都必须在合约的函数内部完成。
- 以太坊合约具备类似数据库事务的特点，如果中途执行失败，则整个合约的状态保持不变，不存在修改某个成员变量后，后续断言失败导致部分修改生效的问题，但是已经执行过的语句仍然会消耗gas



## ACL

- 主要对于合约方法的读写做控制，包括系统合约和用户合约。
- 签名账号的权重之和大于阈值才能有效执行合约
- 一个合约账号可以属于多个账号

> 如果把合约账号当作一家股份制公司，那么ACL便是公司股东投票的机制，ACL可以规定合约账号背后各“股东”账号的权重，只有当“股东”签名的权重之和大于设定阈值时操作才会有效地进行。

```java
{
    "pm": {
        "rule": 1,              # rule=1表示签名阈值策略，rule=2表示AKSet签名策略
        "acceptValue": 0.6      # acceptValue为签名需达到的阈值
    },
    "aksWeight": {              # aksWeight里规定了每个地址对应账号签名的权重
        "AK1": 0.3,
        "AK2": 0.3
    }
}
```

- 如果我们没有制定ACL的具体内容，其ACL被赋值为默认状态，即背后有权限的账号只有**当前节点上默认账号**一个（地址默认位于 data/keys/address）。
- 可以查询，修改一个合约账号的ACL



## 平行链群组





## 治理Token

- 仅用于特定的需要通过投票扭转状态的系统合约
- 目前治理Token被使用在“提案-投票”、共识升级以及作为Tdpos共识代币使用。
- 同样支持转账、锁定与解锁以及查询



## 延迟合约执行机制

- XuperCore 目前提供的智能合约使用了“预执行-执行”流程，当交易被提交到节点后，状态机通过验证后会被更改状态，因此，依托于智能合约的系统合约也同样遵循这样的特点。
- 然而，在区块链系统中，有某些特定场景要求交易以区块粒度被执行，当且仅当该区块被认定为主链上区块且通过验证后，特定的交易才会被触发，基于此，XuperCore提供了一种延迟合约执行机制（被称为Timer。



## 提案Proposal投票

- 提案投票机制依托于Timer实现，其主要功能为从治理委员会中收集针对某特定提案的选票，当选票达到阈值后，在特定区块高度下全网节点触发执行。

- 当某提案被生成后，将会通知全网的节点，全网有治理Token的节点将有权力对其进行投票，提案的状态有如下几种：

![image-20211014211305101](/Users/sens/Library/Application Support/typora-user-images/image-20211014211305101.png)



## 共识升级

- 共识可以升级（改为别的共识）
- 但不能修改配置，不支持升级成同类但配置不同的共识
- 共识升级基于“提案-投票”机制开发。
- 共识升级的先决条件是必须先生成相关治理Token





## 多重签名和环签名

- 多重签名主要用作多人实名授权的交易，通过产生更小的签名数据提升网络传输和计算效率
- 而环签名则主要用于对交易隐私保护和匿名性有要求的交易场景中。





## XuperChain 中密码学的使用

- 使用非对称公私钥对
- 将公钥哈希后，作为账户地址
- 助记词是为了帮助用户保存密钥
- 助记词产生私钥：使用助记词和用户指定的密钥，使用密钥派生算法产生私钥
- 通过助记词恢复密钥：由于用户持有生成密钥的**助记词和口令**，因此在用户私钥遗忘或丢失时，可以通过同样的助记词和口令，**执行助记词产生私钥的过程**，从而恢复出账户密钥。
- **交易签名：** 基于交易数据摘要，会包含交易输入输出、合约调用、合约读写集、发起人和背书人信息等，并将交易数据序列化后的字节数组使用双重SHA256得到摘要数据，最后对摘要数据用ECDSA或其他数字签名算法产生交易签名。
- **块签名：** 基于区块数据摘要，会包含区块元信息如前序块Hash值、交易Merkle树根、打包时间、出块节点等数据，并在序列化后使用双重SHA256得到摘要数据，最后对摘要数据用ECDSA或其他数字签名算法产生区块签名。

![image-20211014233148625](/Users/sens/Library/Application Support/typora-user-images/image-20211014233148625.png)





## 以太坊和比特币在交易层面的区别

比特币交易非常简单，它只做一件事，就是进行交易。 忽略细节，这一切都归结为**TO**（谁收钱），**FROM**（谁汇款）和**AMOUNT**（多少钱）。 这让比特币网络中的参与者可以传递价值并存储价值。

以太坊很大的不同是其交易还有一个`DATA`字段。 DATA字段支持三种类型的交易

- 价值传递 (和比特币相同)
  - **TO** ：收款地址
  - **DATA** ：留空或留言信息
  - **FROM** ：谁发出
  - **AMOUNT** ：发送多少
- 创建合约
  - **TO** ：留空 **(这就是触发创建智能合约的原因)**
  - **DATA** ：包含**编译为字节码**的智能合约代码
  - **FROM** ：谁创建
  - **AMOUNT** ：可以是零或任何数量的以太，它是我们想要**给合约的存款**。
- 调用合约函数
  - **TO**： 目标合约账户地址
  - **DATA**： 包含函数名称和参数 - 标识如何调用智能合约函数
  - **FROM** ：谁调用
  - **AMOUNT** ： 可以是零或任意数量的以太，例如可以支付合约服务费用。



创建合约的交易的 payload 会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。

这意味着，为创建一个合约，你不需要发送实际的合约代码，而是发送能够产生合约代码的代码（字节码）。

> 在合约创建的过程中，它的代码还是空的。所以直到构造函数执行结束，你都不应该在其中调用合约自己函数。

## 成本和执行

- 代码的执行由调用者以称为**Gas**的方式支付费用。
- 发起调用时，须指定调用预计话费的最大gas，（可防止死循环。。。）
- gas执行费用有矿工（运行代码的结点）决定
- 调用智能合约：我们必须将有关调用的信息放入交易中，对其进行签名并发送到以太坊网络中执行。
  - convert funtion call to HEX
  - put the information as data into fransaction object
  - sign the transaction with your private key
  - send the transaction ethereum network





## DAPP架构

一个Dapp应用通常由前端、后端和部署的合约三部分构成。

1. 页面的JavaScript代码无法直接访问以太坊网络的P2P节点，只能间接通过MetaMask钱包访问；
2. 钱包之所以能访问以太坊网络的节点，是因为它们内置了某些公共节点的域名信息；
3. 如果用户的浏览器没有安装MetaMask钱包，则页面无法通过钱包读取合约或写入合约。

- 对于大多数的Dapp来说，是需要服务器端的
- 这是因为，当用户浏览器没有安装钱包，或者钱包并没有连接到Dapp期待的网络时，页面将无法获得合约的任何数据

如果部署一个服务器端，由服务器连接P2P网络的节点并读取合约，然后以JSON API的形式给前端提供相关数据，则可以实现一个更完善的Dapp。

![image-20211018122425383](/Users/sens/Library/Application Support/typora-user-images/image-20211018122425383.png)

为Dapp搭建后端服务器时要严格遵循以下规范：

1. 后端服务器只读取合约，不存储任何私钥，因此无法写入合约，保证了安全性；
2. 后端服务器要读取合约，就必须连接到P2P节点，要么选择公共的节点服务（例如[Infura](https://infura.io/)），要么自己搭建一个以太坊节点（维护的工作量较大）；
3. 后端服务器应该通过合约产生的日志（即合约运行时触发的event）监听合约的状态变化，而不是定期扫描。**监听日志需要通过P2P节点创建Filter并获取Filter返回的日志**；
4. **后端服务器应该将从日志获取的数据做聚合、缓存，以便前端页面能快速展示相关数据**



因此，设计Dapp时，既要考虑将关键业务逻辑写入合约，又要考虑日志输出有足够的信息让后端服务器能聚合历史数据。前端、后端和合约三方开发必须紧密配合。

不同的编程语言实现后端服务时，可以选择封装好的第三方库，例如Java可以使用[Web3j](https://github.com/web3j/web3j)，Python可以使用[Web3.py](https://web3py.readthedocs.io/)，详细的说明可以参考[官方文档](https://ethereum.org/en/developers/docs/programming-languages/)。





## 什么是 NFT 元数据和 TokenURI？

当创建智能合约和创建 NFT 时，人们很快意识到将大量数据部署到区块链是非常昂贵的。小至 1 KB 的图像的存储成本很容易超过 100 万美元。

这显然是 NFT 的一个问题，因为拥有创意艺术意味着您必须将这些信息存储在某个地方。他们还想要一种轻量级的方式来存储有关 NFT 的属性——这就是 tokenURI 和元数据发挥作用的地方。

### TokenURI

NFT 上的 tokenURI 是token“外观”的唯一标识符。URI 可以是通过 HTTPS 的 API 调用、IPFS 哈希值或任何其他独特的东西。

```json
{
"name": "name",
"description": "description",
"image": "https://ipfs.io/ipfs/QmTgqnhFBMkfT9s8PHKcdXBn1f5bG3Q5hmBaR4U6hoTvb1?filename=Chainlink_Elf.png",
"attributes": [
    {
    "trait_type": "trait",
    "value": 100
    }
	]
}
```

这些显示了 NFT 的外观及其属性。图像部分指向 NFT 外观的另一个 URI。这使得 Opensea、Rarible 和 Mintable 等 NFT 平台可以轻松地在其平台上呈现 NFT，因为它们都在寻找这种元数据。

### 链下元数据与链上元数据

现在你可能会想“等等......如果元数据不在链上，这是否意味着我的 NFT 可能会在某个时候消失”？你是对的。

您认为链下元数据意味着您不能使用该元数据让您的智能合约相互交互也是正确的。

这就是为什么我们要专注于链上元数据，以便我们可以对 NFT 进行编程以相互交互。

但是，我们仍然需要链下元数据的图像部分，因为我们没有一种很好的方法来在链上存储大图像。但是别担心，我们仍然可以通过使用 [IPFS](https://blog.chain.link/build-deploy-and-sell-your-own-dynamic-nft/) 在去中心化网络上免费做到这一点。
